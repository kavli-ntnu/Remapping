classdef MapTester < matlab.unittest.TestCase
    properties (Access = protected)
        defaultPos      % Position matrix for tests
        defaultSpikes   % Spikes vector for tests
    end

    methods(TestMethodSetup)
        % run before each method
        function setup(testCase)
            testCase.defaultPos = [
                     0   -7.4654   -5.1228; ...
                0.0200   -7.0599   -5.7310; ...
                0.0400   -6.5438   -6.2456; ...
                0.0600   -6.2488   -6.7135; ...
                0.0800   -5.5853   -6.9006; ...
                0.1000   -4.5899   -6.9006; ...
                0.1200   -3.5576   -6.8538; ...
                0.1400   -2.8940   -6.7602; ...
                0.1600   -2.5253   -5.9649; ...
                0.1800   -2.2304   -5.3567; ...
                0.2000   -1.7512   -6.1520; ...
                0.2200   -0.9032   -6.4327; ...
                0.2400    0.6452   -6.4795; ...
                0.2600    1.1982   -5.6842; ...
                0.2800    0.7926   -4.5614; ...
                0.3000    2.8571   -4.8421; ...
                0.3200    3.5945   -5.7778; ...
                0.3400    4.9217   -5.8713; ...
                0.3600    5.9908   -5.6842; ...
                0.3800    5.6590   -4.6550; ...
                0.4000    4.1475   -4.5614; ...
                0.4200    3.0783   -3.6725; ...
                0.4400    1.7880   -3.7193; ...
                0.4600    1.1982   -4.0936; ...
                0.4800    0.7189   -2.8304; ...
                0.5000    0.4608   -0.8187; ...
                0.5200   -0.2028    0.5848; ...
                0.5400   -0.8664   -0.0234; ...
                0.5600   -0.6820   -1.7076; ...
                0.5800   -1.1982   -3.0175; ...
                0.6000   -3.0783   -3.1579; ...
                0.6200   -3.1889   -3.7661; ...
                0.6400   -3.9631   -4.1871; ...
                0.6600   -4.8479   -3.7661; ...
                0.6800   -5.5484   -3.6725; ...
                0.7000   -5.6959   -2.7368; ...
                0.7200   -6.3963   -2.2222; ...
                0.7400   -6.7281   -1.4269; ...
                0.7600   -6.8387   -0.9591; ...
                0.7800   -5.3641   -0.6316; ...
                0.8000   -5.0691   -1.1462; ...
                0.8200   -4.5899   -2.0351; ...
                0.8400   -4.4793   -2.9708; ...
                0.8600   -3.4470   -2.7368; ...
                0.8800   -3.1521   -2.7836; ...
                0.9000   -2.1567   -1.9883; ...
                0.9200   -2.3410   -1.4737; ...
                0.9400   -2.9677   -1.0058; ...
                0.9600   -3.4839   -0.5848; ...
                0.9800   -4.2949   -0.1637; ...
            ];
            testCase.defaultSpikes = [
                0.0623; ...
                0.1037; ...
                0.1075; ...
                0.1168; ...
                0.2143; ...
                0.2595; ...
                0.3117; ...
                0.3585; ...
                0.3965; ...
                0.4394; ...
                0.4699; ...
                0.5120; ...
                0.5299; ...
                0.5330; ...
                0.5338; ...
                0.5706; ...
                0.6153; ...
                0.6265; ...
                0.6326; ...
                0.6344; ...
                0.7066; ...
                0.7482; ...
                0.8525; ...
                0.9210; ...
                0.9738; ...
            ];
        end
    end

    methods(Test)
        function smallMap(testCase)
            expectedCount = [10 5 3; 2 5 nan; nan nan nan];
            expectedTime = [18 10 7; 9 6 nan; nan nan nan];
            expectedPeakRate = 22.7853;

            pt = testCase.defaultPos;
            [~, spkInd, ~] = data.getSpikePositions(testCase.defaultSpikes, testCase.defaultPos);
            map = analyses.map(pt, pt(spkInd, 1), 'binWidth', 5, 'smooth', 1, 'minTime', 0, 'blanks', 'on', 'limits', [-7.5 7.5 -7.5 7.5]);

            testCase.verifyNotEmpty(map.z);
            testCase.verifyEqual(find(isnan(map.z)), [3 6 8 9]'); %#ok<FNDSB> % no activity in these bins
            testCase.verifyEqual(length(map.x), 4);
            testCase.verifyEqual(length(map.y), 4);
            testCase.verifyEqual(map.countRaw, expectedCount);
            testCase.verifyEqual(round(map.timeRaw * (1/pt(2, 1))), expectedTime);
            peakRate = floor(map.peakRate * 10000) / 10000;
            testCase.verifyEqual(peakRate, expectedPeakRate);
        end

        function oneDimension(testCase)
            pt = testCase.defaultPos;
            spikes = testCase.defaultSpikes;
            pt(:, 3) = nan; % leave only t and x values, but do not remove y!

            expectedCount = [2 4 7 6 3 1 2 nan];
            expectedTime = [7 10 13 6 7 3 4 nan];
            expectedPeakRate = 50;

            [~, spkInd, ~] = data.getSpikePositions(spikes, pt);
            map = analyses.map(pt(:, 1:2), pt(spkInd, 1), 'binWidth', 2, 'smooth', 0, 'minTime', 0, 'blanks', 'on', 'limits', [-8 8]);

            testCase.verifyNotEmpty(map.z);
            testCase.verifyEqual(find(isnan(map.z)), 8); %#ok<FNDSB> % no activity in these bins
            testCase.verifyEqual(length(map.x), 9);
            testCase.verifyEqual(length(map.y), 0);
            testCase.verifyEqual(map.countRaw, expectedCount);
            testCase.verifyEqual(round(map.timeRaw * (1/pt(2, 1))), expectedTime);
            peakRate = floor(map.peakRate * 10000) / 10000;
            testCase.verifyEqual(peakRate, expectedPeakRate, 'AbsTol', 0.0005);
        end

        function speedMap(testCase)
            pt = testCase.defaultPos;
            spikes = testCase.defaultSpikes;

            speed = general.speed(pt);
            [~, spkInd, ~] = data.getSpikePositions(spikes, pt);
            speedMap = analyses.map([pt(:, 1) speed], pt(spkInd, 1), 'binWidth', 2, 'smooth', 0, 'minTime', 0, 'blanks', 'on', 'limits', [0 50]);
        end

        function singlePositionSample(testCase)
            pt = testCase.defaultPos;
            spikes = testCase.defaultSpikes;
            badInd = true(size(pt, 1), 1);
            badInd(6) = false;
            pt(badInd, 2) = nan;
            pt(badInd, 3) = nan;

            [~, spkInd, ~] = data.getSpikePositions(spikes, pt);
            map = analyses.map(pt, pt(spkInd, 1), 'binWidth', 5, 'smooth', 1, 'minTime', 0, 'blanks', 'on');
            testCase.verifyEqual(map.z, []);
        end

        function nonMonotonicTime(testCase)
            % no samples between 0.38 and 0.6
            pos = [
                     0   -7.4654   -5.1228; ...
                0.0200   -7.0599   -5.7310; ...
                0.0400   -6.5438   -6.2456; ...
                0.0600   -6.2488   -6.7135; ...
                0.0800   -5.5853   -6.9006; ...
                0.1000   -4.5899   -6.9006; ...
                0.1200   -3.5576   -6.8538; ...
                0.1400   -2.8940   -6.7602; ...
                0.1600   -2.5253   -5.9649; ...
                0.1800   -2.2304   -5.3567; ...
                0.2000   -1.7512   -6.1520; ...
                0.2200   -0.9032   -6.4327; ...
                0.2400    0.6452   -6.4795; ...
                0.2600    1.1982   -5.6842; ...
                0.2800    0.7926   -4.5614; ...
                0.3000    2.8571   -4.8421; ...
                0.3200    3.5945   -5.7778; ...
                0.3400    4.9217   -5.8713; ...
                0.3600    5.9908   -5.6842; ...
                0.3800    5.6590   -4.6550; ...
                0.6000   -3.0783   -3.1579; ...
                0.6200   -3.1889   -3.7661; ...
                0.6400   -3.9631   -4.1871; ...
                0.6600   -4.8479   -3.7661; ...
                0.6800   -5.5484   -3.6725; ...
                0.7000   -5.6959   -2.7368; ...
                0.7200   -6.3963   -2.2222; ...
                0.7400   -6.7281   -1.4269; ...
                0.7600   -6.8387   -0.9591; ...
                0.7800   -5.3641   -0.6316; ...
                0.8000   -5.0691   -1.1462; ...
                0.8200   -4.5899   -2.0351; ...
                0.8400   -4.4793   -2.9708; ...
                0.8600   -3.4470   -2.7368; ...
                0.8800   -3.1521   -2.7836; ...
                0.9000   -2.1567   -1.9883; ...
                0.9200   -2.3410   -1.4737; ...
                0.9400   -2.9677   -1.0058; ...
                0.9600   -3.4839   -0.5848; ...
                0.9800   -4.2949   -0.1637; ...
            ];
            spikes = [
                0.0623; ...
                0.1037; ...
                0.1075; ...
                0.1168; ...
                0.2143; ...
                0.2595; ...
                0.3117; ...
                0.3585; ...
                0.6153; ...
                0.6265; ...
                0.6326; ...
                0.6344; ...
                0.7066; ...
                0.7482; ...
                0.8525; ...
                0.9210; ...
                0.9738; ...
            ];

            [~, spkInd, ~] = data.getSpikePositions(spikes, pos);
            map = analyses.map(pos, pos(spkInd, 1), 'binWidth', 5, 'smooth', 1, 'minTime', 0, 'blanks', 'on', 'maxGap', 0.1);

            testCase.verifyEqual(map.Nspikes, [10 2 2; 2 1 0]);

            % it is questionable that a point in (1, 3) should be assigned time difference of 0.1.
            % Maybe (1, 1) is a better candidate, but for this one have to do: dtTmp = diff(post);
            % dt(1) = dtTmp(1); dt(2:length(dtTmp)+1) = dtTmp;
            testTime(2, 1) = 7 * 0.02;
            testTime(2, 2) = 1 * 0.02;
            testTime(2, 3) = nan;
            testTime(1, 1) = 20 * 0.02;
            testTime(1, 2) = 7 * 0.02;
            testTime(1, 3) = 4*0.02 + 1*0.1;

            testCase.verifyEqual(map.timeRaw, testTime);
        end
    end
end